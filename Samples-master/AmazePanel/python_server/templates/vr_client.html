<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>VR Streamer · Quest Viewer</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Noto Sans KR', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: #050505;
            color: #f5f5f5;
            overflow: hidden;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at top, #10131c, #050505);
        }

        #vrCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 22px 32px 12px;
            background: linear-gradient(180deg, rgba(10, 10, 10, 0.9), rgba(10, 10, 10, 0.2));
            pointer-events: auto;
        }

        .title-block h1 {
            font-size: 28px;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .title-block p {
            color: rgba(255, 255, 255, 0.75);
            font-size: 13px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .status-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.55);
        }

        .status-chip .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .status-chip.online .dot {
            background: #2ecc71;
            border-color: #16854a;
        }

        .status-chip.offline .dot {
            background: #ff6b6b;
            border-color: #c0392b;
        }

        #network-speed-indicator {
            position: absolute;
            bottom: 170px;
            right: 32px;
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 14px 22px;
            border-radius: 16px;
            background: rgba(4, 10, 25, 0.78);
            border: 1px solid rgba(79, 195, 247, 0.35);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.45);
            pointer-events: auto;
        }

        .speed-icon {
            font-size: 26px;
            color: #4fc3f7;
        }

        .speed-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 160px;
        }

        .speed-value {
            font-size: 20px;
            font-weight: 700;
        }

        .speed-label {
            font-size: 12px;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
        }

        .speed-latency {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        #ui-toggle-corner-btn {
            position: absolute;
            top: 24px;
            left: 24px;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 16px;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ui-toggle-corner-btn:hover {
            transform: scale(1.08);
            border-color: #4fc3f7;
        }

        body.overlay-hidden #header,
        body.overlay-hidden #control-panel,
        body.overlay-hidden #network-speed-indicator {
            opacity: 0;
            pointer-events: none;
        }

        #control-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 24px 30px 32px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 18px;
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.25s ease;
        }

        .panel-card {
            background: rgba(0, 0, 0, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 18px;
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.55);
            backdrop-filter: blur(10px);
        }

        .panel-card h3 {
            font-size: 16px;
            letter-spacing: 0.08em;
            margin-bottom: 12px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.85);
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            pointer-events: auto;
            border: none;
            border-radius: 10px;
            padding: 10px 16px;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.03em;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s, opacity 0.2s;
        }

        .primary-btn {
            background: linear-gradient(135deg, #2e8bff, #1f6ad7);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .ghost-btn {
            background: rgba(255, 255, 255, 0.08);
            color: #eee;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        button:active {
            transform: scale(0.97);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 14px;
        }

        .slider-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.25);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2e8bff;
            border: 2px solid rgba(255, 255, 255, 0.7);
            cursor: pointer;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 13px;
            cursor: pointer;
        }

        select option {
            background: #1a1a1a;
            color: #fff;
        }

        #instruction-list {
            font-size: 13px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.85);
            list-style: decimal;
            padding-left: 18px;
        }

        .control-toggle-btn {
            position: absolute;
            left: 32px;
            z-index: 5;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 10px 18px;
            border-radius: 999px;
            border: 1px solid rgba(79, 195, 247, 0.6);
            background: rgba(0, 0, 0, 0.78);
            color: #e6f7ff;
            font-size: 12px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            pointer-events: auto;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
        }

        #controlCollapseBtn {
            top: 140px;
        }

        #controlCompactBtn {
            top: 190px;
        }

        .control-toggle-btn::before {
            font-size: 15px;
            opacity: 0.9;
        }

        #controlCollapseBtn::before {
            content: '⇕';
        }

        #controlCompactBtn::before {
            content: '☰';
        }

        .control-toggle-btn:hover {
            background: rgba(47, 128, 237, 0.85);
            color: #fff;
        }

        body.controls-collapsed #control-panel {
            transform: translateY(110%);
            opacity: 0;
            pointer-events: none;
        }

        body.controls-collapsed #controlCollapseBtn {
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
        }

        #mini-preview {
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: #000;
            width: 100%;
            height: 140px;
            object-fit: cover;
        }

        #log {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            max-height: 90px;
            overflow: hidden;
        }

        body.controls-compact #control-panel {
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            padding: 18px 20px 24px;
            gap: 12px;
            max-width: min(1200px, 95vw);
            margin: 0 auto;
        }

        body.controls-compact .panel-card {
            padding: 14px;
        }

        body.controls-compact .panel-card h3 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        body.controls-compact #mini-preview {
            height: 90px;
        }

        @media (max-width: 1500px) {
            #control-panel {
                grid-template-columns: repeat(2, minmax(260px, 1fr));
            }
        }

        @media (max-width: 1180px) {
            #header {
                flex-direction: column;
                gap: 14px;
            }

            #network-speed-indicator {
                position: static;
                margin: 16px 32px 0 auto;
            }

            #control-panel {
                grid-template-columns: 1fr;
            }

            #controlCollapseBtn,
            #controlCompactBtn {
                top: auto;
                bottom: 24px;
                left: auto;
                right: 32px;
            }

            #controlCompactBtn {
                bottom: 70px;
            }
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="vrCanvas"></canvas>
        <div id="ui-overlay">
            <div id="header">
                <div class="title-block">
                    <h1>VR Streamer</h1>
                    <p>Premiere Monitor → Quest WebXR</p>
                </div>
                <div class="status-group">
                    <div class="status-chip offline" id="serverStatusChip">
                        <span class="dot"></span>
                        <span id="serverStatusLabel">Server offline</span>
                    </div>
                    <div class="status-chip" id="vrModeChip">
                        <span class="dot" style="background:#4fc3f7;border-color:#1d9ce5;"></span>
                        <span id="vrModeLabel">Desktop Preview</span>
                    </div>
                    <div class="status-chip" id="ipChip">
                        <span class="dot" style="background:#feb72b;border-color:#b37400;"></span>
                        <span id="ipLabel">IP: -</span>
                    </div>
                </div>
            </div>

            <button id="ui-toggle-corner-btn" title="UI 숨기기">◐</button>

            <div id="network-speed-indicator">
                <div class="speed-icon">⇅</div>
                <div class="speed-text">
                    <span class="speed-label">STREAM BANDWIDTH</span>
                    <span class="speed-value" id="networkSpeed">-- Mbps</span>
                </div>
                <div class="speed-latency" id="networkLatency">Latency -- ms</div>
            </div>

            <div id="control-panel">
                <div class="panel-card">
                    <h3>Immersion</h3>
                    <div class="button-row" style="margin-bottom:12px;">
                        <button class="primary-btn" id="enterVrBtn">Enter VR</button>
                        <button class="ghost-btn" id="recenterBtn">Re-center</button>
                        <button class="ghost-btn" id="toggleEnvBtn">Toggle Lights</button>
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Projection</span>
                        </div>
                        <select id="projectionSelect">
                            <option value="flat">Flat Screen</option>
                            <option value="curved">Curved Screen</option>
                            <option value="180">VR 180 (Mono)</option>
                            <option value="180_sbs">VR 180 (Stereo SBS)</option>
                            <option value="180_tb">VR 180 (Stereo TB)</option>
                        </select>
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Screen Distance</span>
                            <span id="distanceValue">3.2m</span>
                        </div>
                        <input type="range" id="distanceSlider" min="2" max="5" step="0.1" value="3.2">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Curvature</span>
                            <span id="curvatureValue">0%</span>
                        </div>
                        <input type="range" id="curvatureSlider" min="0" max="100" value="0">
                    </div>
                </div>

                <div class="panel-card">
                    <h3>Stream</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Frame Rate</span>
                            <span id="fpsValue">24 FPS</span>
                        </div>
                        <input type="range" id="fpsSlider" min="5" max="45" value="24">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Sharpness</span>
                            <span id="qualityValue">80%</span>
                        </div>
                        <input type="range" id="qualitySlider" min="40" max="95" value="80">
                    </div>
                    <div class="button-row" style="margin-top:8px;">
                        <button class="ghost-btn" id="refreshHealthBtn">Check Health</button>
                        <button class="ghost-btn" id="togglePreviewBtn">Toggle Preview</button>
                    </div>
                    <p style="font-size:12px;color:rgba(255,255,255,0.7);margin-top:12px;" id="vrStatusMessage">
                        서버에 연결 중입니다...
                    </p>
                </div>

                <div class="panel-card">
                    <h3>Quest Checklist</h3>
                    <ul id="instruction-list">
                        <li>PC와 Quest가 동일 네트워크인지 확인</li>
                        <li>헤드셋 브라우저에서 <code id="questUrl">http://&lt;IP&gt;:5000</code> 접속</li>
                        <li>페이지가 열리면 "Enter VR"을 눌러 WebXR 세션 시작</li>
                        <li>프레임이 느리면 FPS 혹은 품질 슬라이더로 조절</li>
                    </ul>
                    <img id="mini-preview" alt="Stream preview">
                </div>

                <div class="panel-card">
                    <h3>Telemetry</h3>
                    <div id="log">Ready.</div>
                </div>
            </div>
            <button id="controlCollapseBtn" class="control-toggle-btn" aria-expanded="true">Hide Controls</button>
            <button id="controlCompactBtn" class="control-toggle-btn" aria-pressed="false">Compact Layout</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from '/static/vendor/three/three.module.js';
        import { OrbitControls } from '/static/vendor/three/OrbitControls.js';
        import { VRButton } from '/static/vendor/three/VRButton.js';

        const canvas = document.getElementById('vrCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        const vrButton = VRButton.createButton(renderer);
        vrButton.style.display = 'none';
        document.body.appendChild(vrButton);

        let xrSession = null;
        const xrSessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers'],
            requiredFeatures: ['local-floor']
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 3.2);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.6, 0);
        controls.enableDamping = true;
        controls.enablePan = false;

        const ambient = new THREE.AmbientLight(0xffffff, 0.45);
        const keyLight = new THREE.SpotLight(0x89c4ff, 1.1, 20, Math.PI / 4, 0.25, 1);
        keyLight.position.set(-3, 4, 2);
        const rimLight = new THREE.PointLight(0xffb347, 0.6, 10);
        rimLight.position.set(3, 1.8, 1.5);
        scene.add(ambient, keyLight, rimLight);

        const floor = new THREE.Mesh(
            new THREE.CircleGeometry(40, 64),
            new THREE.MeshStandardMaterial({ color: 0x0d0d0d, roughness: 0.85, metalness: 0.05 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        scene.add(floor);

        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = 1280;
        frameCanvas.height = 720;
        const frameCtx = frameCanvas.getContext('2d');
        frameCtx.fillStyle = "#000";
        frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);

        const frameTexture = new THREE.CanvasTexture(frameCanvas);
        frameTexture.encoding = THREE.sRGBEncoding;
        frameTexture.minFilter = THREE.LinearFilter;
        frameTexture.magFilter = THREE.LinearFilter;
        frameTexture.anisotropy = 4;

        const screenMaterial = new THREE.MeshBasicMaterial({
            map: frameTexture,
            side: THREE.DoubleSide,
            toneMapped: false
        });

        const matLeft = screenMaterial.clone();
        const matRight = screenMaterial.clone();

        let screenMesh, screenMeshR;
        const screenState = {
            width: 4.0,
            height: 4.0 / (16 / 9),
            distance: 3.2,
            curvature: 0,
            projection: 'flat'
        };

        function buildScreen() {
            if (screenMesh) {
                scene.remove(screenMesh);
                if (screenMesh.geometry) screenMesh.geometry.dispose();
            }
            if (screenMeshR) {
                scene.remove(screenMeshR);
                if (screenMeshR.geometry) screenMeshR.geometry.dispose();
                screenMeshR = null;
            }

            screenMaterial.map.repeat.set(1, 1);
            screenMaterial.map.offset.set(0, 0);
            matLeft.map = frameTexture;
            matRight.map = frameTexture;
            matLeft.map.repeat.set(1, 1);
            matLeft.map.offset.set(0, 0);
            matRight.map.repeat.set(1, 1);
            matRight.map.offset.set(0, 0);

            const mode = screenState.projection;

            if (mode === 'flat' || mode === 'curved') {
                let geometry;
                if (screenState.curvature < 0.05 && mode !== 'curved') {
                    geometry = new THREE.PlaneGeometry(screenState.width, screenState.height, 32, 1);
                } else {
                    const segments = 96;
                    geometry = new THREE.PlaneGeometry(screenState.width, screenState.height, segments, 1);
                    const arc = THREE.MathUtils.lerp(Math.PI / 60, Math.PI / 1.4, screenState.curvature);
                    const radius = screenState.width / arc;
                    const pos = geometry.attributes.position;
                    for (let i = 0; i < pos.count; i++) {
                        const x = pos.getX(i);
                        const angle = (x / screenState.width) * arc;
                        const targetX = Math.sin(angle) * radius;
                        const targetZ = radius - Math.cos(angle) * radius;
                        pos.setX(i, targetX);
                        pos.setZ(i, targetZ);
                    }
                    pos.needsUpdate = true;
                    geometry.computeVertexNormals();
                }
                screenMesh = new THREE.Mesh(geometry, screenMaterial);
                screenMesh.position.set(0, 1.6, -screenState.distance);
                screenMesh.layers.enable(1);
                screenMesh.layers.enable(2);
                scene.add(screenMesh);

            } else if (mode.startsWith('180')) {
                const geometry = new THREE.SphereGeometry(screenState.distance, 64, 32, 0, Math.PI, 0, Math.PI);
                geometry.scale(-1, 1, 1);

                if (mode === '180') {
                    screenMesh = new THREE.Mesh(geometry, screenMaterial);
                    screenMesh.position.set(0, 1.6, 0);
                    screenMesh.rotation.y = -Math.PI / 2;
                    screenMesh.layers.enable(1);
                    screenMesh.layers.enable(2);
                    scene.add(screenMesh);
                } else {
                    const isSBS = mode === '180_sbs';

                    matLeft.map.repeat.set(isSBS ? 0.5 : 1, isSBS ? 1 : 0.5);
                    matLeft.map.offset.set(0, isSBS ? 0 : 0.5);

                    screenMesh = new THREE.Mesh(geometry, matLeft);
                    screenMesh.position.set(0, 1.6, 0);
                    screenMesh.rotation.y = -Math.PI / 2;
                    screenMesh.layers.set(1);
                    scene.add(screenMesh);

                    matRight.map.repeat.set(isSBS ? 0.5 : 1, isSBS ? 1 : 0.5);
                    matRight.map.offset.set(isSBS ? 0.5 : 0, 0);

                    screenMeshR = new THREE.Mesh(geometry.clone(), matRight);
                    screenMeshR.position.set(0, 1.6, 0);
                    screenMeshR.rotation.y = -Math.PI / 2;
                    screenMeshR.layers.set(2);
                    scene.add(screenMeshR);
                }
            }
        }

        buildScreen();

        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        window.addEventListener('resize', resizeRenderer);

        function animate() {
            renderer.setAnimationLoop(() => {
                if (!renderer.xr.isPresenting) {
                    controls.update();
                }
                renderer.render(scene, camera);
            });
        }

        animate();

        const state = {
            streaming: true,
            fps: 24,
            quality: 80,
            lightsOn: true,
            previewVisible: true,
            useFrameEndpoint: true
        };

        const logEl = document.getElementById('log');
        function log(message) {
            const time = new Date().toLocaleTimeString();
            logEl.textContent = `[${time}] ${message}\n` + logEl.textContent;
        }

        const serverStatusChip = document.getElementById('serverStatusChip');
        const serverStatusLabel = document.getElementById('serverStatusLabel');
        const vrModeLabel = document.getElementById('vrModeLabel');
        const ipLabel = document.getElementById('ipLabel');
        const questUrl = document.getElementById('questUrl');
        const statusMessage = document.getElementById('vrStatusMessage');
        const miniPreview = document.getElementById('mini-preview');
        miniPreview.crossOrigin = "anonymous";
        miniPreview.src = "/video_feed";
        const collapseBtn = document.getElementById('controlCollapseBtn');
        const compactBtn = document.getElementById('controlCompactBtn');
        let controlsCollapsed = false;
        let controlsCompact = window.innerWidth < 1500;
        let compactManualOverride = false;

        function updateCollapseState() {
            document.body.classList.toggle('controls-collapsed', controlsCollapsed);
            if (collapseBtn) {
                collapseBtn.textContent = controlsCollapsed ? 'Show Controls' : 'Hide Controls';
                collapseBtn.setAttribute('aria-expanded', (!controlsCollapsed).toString());
            }
        }

        function updateCompactState() {
            document.body.classList.toggle('controls-compact', controlsCompact);
            if (compactBtn) {
                compactBtn.textContent = controlsCompact ? 'Full Layout' : 'Compact Layout';
                compactBtn.setAttribute('aria-pressed', controlsCompact ? 'true' : 'false');
            }
        }

        if (collapseBtn) {
            collapseBtn.addEventListener('click', () => {
                controlsCollapsed = !controlsCollapsed;
                updateCollapseState();
            });
        }
        updateCollapseState();

        if (compactBtn) {
            compactBtn.addEventListener('click', () => {
                controlsCompact = !controlsCompact;
                compactManualOverride = true;
                updateCompactState();
            });
        }
        updateCompactState();

        const compactMedia = window.matchMedia('(max-width: 1500px)');
        const compactMediaHandler = (evt) => {
            if (compactManualOverride) return;
            controlsCompact = evt.matches;
            updateCompactState();
        };
        if (compactMedia.addEventListener) {
            compactMedia.addEventListener('change', compactMediaHandler);
        } else if (compactMedia.addListener) {
            compactMedia.addListener(compactMediaHandler);
        }

        function setServerStatus(text, online) {
            serverStatusLabel.textContent = text;
            serverStatusChip.classList.remove('online', 'offline');
            serverStatusChip.classList.add(online ? 'online' : 'offline');
        }

        function updateNetworkIndicator(bytes, elapsedMs) {
            const bits = bytes * 8;
            const kbps = bits / elapsedMs;
            const mbps = (kbps / 1000).toFixed(2);
            document.getElementById('networkSpeed').textContent = `${mbps} Mbps`;
            document.getElementById('networkLatency').textContent = `Latency ${Math.round(elapsedMs)} ms`;
        }

        async function fetchFrameLoop() {
            let errorCount = 0;
            while (state.streaming && state.useFrameEndpoint) {
                const start = performance.now();
                try {
                    const response = await fetch(`/frame.jpg?ts=${Date.now()}`, { cache: "no-store" });
                    if (!response.ok) {
                        throw new Error(response.statusText);
                    }
                    const blob = await response.blob();
                    const bitmap = await createImageBitmap(blob);
                    if (frameCanvas.width !== bitmap.width || frameCanvas.height !== bitmap.height) {
                        frameCanvas.width = bitmap.width;
                        frameCanvas.height = bitmap.height;
                    }
                    frameCtx.drawImage(bitmap, 0, 0, frameCanvas.width, frameCanvas.height);
                    frameTexture.needsUpdate = true;
                    statusMessage.textContent = "스트림 연결됨. VR 버튼을 눌러 감상하세요.";
                    setServerStatus("Server online", true);
                    updateNetworkIndicator(blob.size, performance.now() - start);
                    errorCount = 0;
                } catch (err) {
                    errorCount++;
                    console.warn(`Frame fetch error ${errorCount}:`, err);
                    if (errorCount > 5) {
                        console.warn("Too many errors, falling back to MJPEG stream.");
                        statusMessage.textContent = "연결 불안정. 백업 스트림으로 전환합니다.";
                        startMjpegFallback();
                        break;
                    }

                    statusMessage.textContent = `프레임 수신 실패: ${err.message}`;
                    setServerStatus("Server offline", false);
                    await new Promise(r => setTimeout(r, 1000));
                }

                const elapsed = performance.now() - start;
                const wait = Math.max(5, (1000 / state.fps) - elapsed);
                await new Promise(r => setTimeout(r, wait));
            }
        }

        function startMjpegFallback() {
            state.useFrameEndpoint = false;
            setServerStatus("Server online", true);
            statusMessage.textContent = "스트림 연결됨 (MJPEG fallback).";
            log("frame.jpg unavailable. Using /video_feed stream for canvas texture.");

            function pump() {
                if (state.useFrameEndpoint || !state.streaming) {
                    return;
                }
                if (miniPreview.naturalWidth > 0 && miniPreview.naturalHeight > 0) {
                    if (frameCanvas.width !== miniPreview.naturalWidth || frameCanvas.height !== miniPreview.naturalHeight) {
                        frameCanvas.width = miniPreview.naturalWidth;
                        frameCanvas.height = miniPreview.naturalHeight;
                    }
                    frameCtx.drawImage(miniPreview, 0, 0, frameCanvas.width, frameCanvas.height);
                    frameTexture.needsUpdate = true;
                }
                if (!state.useFrameEndpoint && state.streaming) {
                    requestAnimationFrame(pump);
                }
            }

            pump();
        }

        async function probeFrameEndpoint() {
            try {
                const res = await fetch(`/frame.jpg?probe=${Date.now()}`, { cache: "no-store" });
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }
                await res.blob();
                return true;
            } catch (err) {
                log(`frame.jpg unavailable (${err.message}). Falling back to /video_feed.`);
                return false;
            }
        }

        async function beginStreaming() {
            startMjpegFallback();
            const hasFrameEndpoint = await probeFrameEndpoint();
            if (hasFrameEndpoint) {
                state.useFrameEndpoint = true;
                fetchFrameLoop();
            }
        }

        beginStreaming();

        async function refreshHealth() {
            try {
                const res = await fetch('/health', { cache: 'no-store' });
                const data = await res.json();
                if (data.ip) {
                    ipLabel.textContent = `IP: ${data.ip}`;
                    questUrl.textContent = `http://${data.ip}:5000`;
                }
                if (data.bbox) {
                    frameCanvas.width = data.bbox.width;
                    frameCanvas.height = data.bbox.height;
                }
                setServerStatus("Server online", true);
                statusMessage.textContent = "Quest에서 같은 주소로 접속하세요.";
            } catch (err) {
                setServerStatus("Server offline", false);
                statusMessage.textContent = "서버에 연결할 수 없습니다.";
                log(`Health check failed: ${err.message}`);
            }
        }

        refreshHealth();
        setInterval(refreshHealth, 15000);

        document.getElementById('fpsSlider').addEventListener('input', (e) => {
            state.fps = parseInt(e.target.value, 10);
            document.getElementById('fpsValue').textContent = `${state.fps} FPS`;
            fetch('/update_config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fps: state.fps })
            }).catch(() => { });
        });

        document.getElementById('qualitySlider').addEventListener('input', (e) => {
            state.quality = parseInt(e.target.value, 10);
            document.getElementById('qualityValue').textContent = `${state.quality}%`;
            fetch('/update_config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ quality: state.quality })
            }).catch(() => { });
        });

        document.getElementById('distanceSlider').addEventListener('input', (e) => {
            screenState.distance = parseFloat(e.target.value);
            document.getElementById('distanceValue').textContent = `${screenState.distance.toFixed(1)}m`;
            buildScreen();
        });

        document.getElementById('curvatureSlider').addEventListener('input', (e) => {
            screenState.curvature = parseInt(e.target.value, 10) / 100;
            document.getElementById('curvatureValue').textContent = `${e.target.value}%`;
            buildScreen();
        });

        document.getElementById('projectionSelect').addEventListener('change', (e) => {
            screenState.projection = e.target.value;
            buildScreen();
        });

        document.getElementById('toggleEnvBtn').addEventListener('click', () => {
            state.lightsOn = !state.lightsOn;
            keyLight.visible = state.lightsOn;
            rimLight.visible = state.lightsOn;
            log(`Lights ${state.lightsOn ? 'on' : 'off'}`);
        });

        document.getElementById('togglePreviewBtn').addEventListener('click', () => {
            state.previewVisible = !state.previewVisible;
            miniPreview.style.display = state.previewVisible ? 'block' : 'none';
        });

        document.getElementById('refreshHealthBtn').addEventListener('click', refreshHealth);

        document.getElementById('recenterBtn').addEventListener('click', () => {
            camera.position.set(0, 1.6, screenState.distance);
            controls.target.set(0, 1.6, 0);
            controls.update();
            log('Camera re-centered');
        });

        const enterVrBtn = document.getElementById('enterVrBtn');

        async function startVrSession() {
            if (!navigator.xr) {
                alert('이 브라우저는 WebXR을 지원하지 않습니다.');
                return;
            }
            if (xrSession) {
                try {
                    await xrSession.end();
                } catch (err) {
                    log(`세션 종료 실패: ${err.message}`);
                }
                return;
            }
            try {
                const session = await navigator.xr.requestSession('immersive-vr', xrSessionInit);
                await renderer.xr.setSession(session);
                xrSession = session;
                enterVrBtn.textContent = 'Exit VR';
                log('VR 세션 시작');
                session.addEventListener('end', () => {
                    xrSession = null;
                    enterVrBtn.textContent = 'Enter VR';
                    log('VR 세션 종료');
                }, { once: true });
            } catch (err) {
                log(`VR 세션 시작 실패: ${err.message}`);
                alert('VR 세션을 시작할 수 없습니다.\n' + err.message);
            }
        }

        enterVrBtn.addEventListener('click', () => {
            if (!navigator.xr) {
                alert('WebXR을 지원하지 않는 환경입니다.');
                return;
            }
            startVrSession();
        });

        renderer.xr.addEventListener('sessionstart', () => {
            vrModeLabel.textContent = 'VR Session Active';
            enterVrBtn.textContent = 'Exit VR';
        });

        renderer.xr.addEventListener('sessionend', () => {
            vrModeLabel.textContent = 'Desktop Preview';
            enterVrBtn.textContent = 'Enter VR';
        });

        document.getElementById('ui-toggle-corner-btn').addEventListener('click', () => {
            document.body.classList.toggle('overlay-hidden');
        });
    </script>
</body>

</html>