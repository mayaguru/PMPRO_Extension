<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>VR Streamer · Quest Viewer</title>
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <style>
        :root {
            color-scheme: dark;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Noto Sans KR', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            background: #050505;
            color: #f5f5f5;
            overflow: hidden;
        }

        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at top, #10131c, #050505);
        }

        #vrCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }

        #header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 22px 32px 12px;
            background: linear-gradient(180deg, rgba(10, 10, 10, 0.9), rgba(10, 10, 10, 0.2));
            pointer-events: auto;
        }

        .title-block h1 {
            font-size: 28px;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .title-block p {
            color: rgba(255, 255, 255, 0.75);
            font-size: 13px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .status-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.55);
        }

        .status-chip .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.4);
        }

        .status-chip.online .dot {
            background: #2ecc71;
            border-color: #16854a;
        }

        .status-chip.offline .dot {
            background: #ff6b6b;
            border-color: #c0392b;
        }

        .status-chip.warning .dot {
            background: #f5a623;
            border-color: #d68910;
        }

        #network-speed-indicator {
            position: absolute;
            bottom: 170px;
            right: 32px;
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 14px 22px;
            border-radius: 16px;
            background: rgba(4, 10, 25, 0.78);
            border: 1px solid rgba(79, 195, 247, 0.35);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.45);
            pointer-events: auto;
        }

        .speed-icon {
            font-size: 26px;
            color: #4fc3f7;
        }

        .speed-text {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 160px;
        }

        .speed-value {
            font-size: 20px;
            font-weight: 700;
        }

        .speed-label {
            font-size: 12px;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
        }

        .speed-latency {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        #ui-toggle-corner-btn {
            position: absolute;
            top: 24px;
            left: 24px;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.55);
            color: #fff;
            font-size: 16px;
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ui-toggle-corner-btn:hover {
            transform: scale(1.08);
            border-color: #4fc3f7;
        }

        body.overlay-hidden #header,
        body.overlay-hidden #control-panel,
        body.overlay-hidden #network-speed-indicator {
            opacity: 0;
            pointer-events: none;
        }

        #control-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 24px 30px 32px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 18px;
            pointer-events: auto;
            transition: transform 0.3s ease, opacity 0.25s ease;
        }

        .panel-card {
            background: rgba(0, 0, 0, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 18px;
            padding: 18px;
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.55);
            backdrop-filter: blur(10px);
        }

        .panel-card h3 {
            font-size: 16px;
            letter-spacing: 0.08em;
            margin-bottom: 12px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.85);
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        button {
            pointer-events: auto;
            border: none;
            border-radius: 10px;
            padding: 10px 16px;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.03em;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s, opacity 0.2s;
        }

        .primary-btn {
            background: linear-gradient(135deg, #2e8bff, #1f6ad7);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .ghost-btn {
            background: rgba(255, 255, 255, 0.08);
            color: #eee;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        button:active {
            transform: scale(0.97);
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 14px;
        }

        .slider-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: space-between;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.25);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #2e8bff;
            border: 2px solid rgba(255, 255, 255, 0.7);
            cursor: pointer;
        }

        .stereo-control-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stereo-toggle-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .stereo-toggle-btn {
            flex: 1 1 120px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.06);
            color: #fff;
            font-size: 13px;
            padding: 8px 16px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s;
        }

        .stereo-toggle-btn.active {
            background: linear-gradient(135deg, #b138f5, #7a1eb8);
            border-color: rgba(255, 255, 255, 0.45);
        }

        .stereo-toggle-btn.cannon-active {
            background: linear-gradient(135deg, #ff8a50, #ff5722);
            border-color: rgba(255, 255, 255, 0.45);
        }

        .eye-toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: rgba(255, 255, 255, 0.7);
        }

        .eye-btn-group {
            display: inline-flex;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            overflow: hidden;
        }

        .eye-btn-group button {
            background: transparent;
            border: none;
            color: #fff;
            font-size: 12px;
            padding: 6px 14px;
            cursor: pointer;
        }

        .eye-btn-group button.active {
            background: rgba(255, 255, 255, 0.18);
        }

        #instruction-list {
            font-size: 13px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.85);
            list-style: decimal;
            padding-left: 18px;
        }

        .control-toggle-btn {
            position: absolute;
            left: 32px;
            z-index: 5;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 10px 18px;
            border-radius: 999px;
            border: 1px solid rgba(79, 195, 247, 0.6);
            background: rgba(0, 0, 0, 0.78);
            color: #e6f7ff;
            font-size: 12px;
            letter-spacing: 0.06em;
            text-transform: uppercase;
            pointer-events: auto;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.45);
        }

        #controlCollapseBtn {
            top: 140px;
        }

        #controlCompactBtn {
            top: 190px;
        }

        .control-toggle-btn::before {
            font-size: 15px;
            opacity: 0.9;
        }

        #controlCollapseBtn::before {
            content: '⇕';
        }

        #controlCompactBtn::before {
            content: '☰';
        }

        .control-toggle-btn:hover {
            background: rgba(47, 128, 237, 0.85);
            color: #fff;
        }

        body.controls-collapsed #control-panel {
            transform: translateY(110%);
            opacity: 0;
            pointer-events: none;
        }

        body.controls-collapsed #controlCollapseBtn {
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
        }

        #mini-preview {
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: #000;
            width: 100%;
            height: 140px;
            object-fit: cover;
        }

        #log {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            max-height: 90px;
            overflow: hidden;
        }

        body.controls-compact #control-panel {
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            padding: 18px 20px 24px;
            gap: 12px;
            max-width: min(1200px, 95vw);
            margin: 0 auto;
        }

        body.controls-compact .panel-card {
            padding: 14px;
        }

        body.controls-compact .panel-card h3 {
            font-size: 14px;
            margin-bottom: 8px;
        }

        body.controls-compact #mini-preview {
            height: 90px;
        }

        @media (max-width: 1500px) {
            #control-panel {
                grid-template-columns: repeat(2, minmax(260px, 1fr));
            }
        }

        @media (max-width: 1180px) {
            #header {
                flex-direction: column;
                gap: 14px;
            }

            #network-speed-indicator {
                position: static;
                margin: 16px 32px 0 auto;
            }

            #control-panel {
                grid-template-columns: 1fr;
            }

            #controlCollapseBtn,
            #controlCompactBtn {
                top: auto;
                bottom: 24px;
                left: auto;
                right: 32px;
            }

            #controlCompactBtn {
                bottom: 70px;
            }
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="vrCanvas"></canvas>
        <div id="ui-overlay">
            <div id="header">
                <div class="title-block">
                    <h1>VR Streamer</h1>
                    <p>Premiere Monitor → Quest WebXR</p>
                </div>
                <div class="status-group">
                    <div class="status-chip offline" id="serverStatusChip">
                        <span class="dot"></span>
                        <span id="serverStatusLabel">Server offline</span>
                    </div>
                    <div class="status-chip" id="vrModeChip">
                        <span class="dot" style="background:#4fc3f7;border-color:#1d9ce5;"></span>
                        <span id="vrModeLabel">Desktop Preview</span>
                    </div>
                    <div class="status-chip" id="ipChip">
                        <span class="dot" style="background:#feb72b;border-color:#b37400;"></span>
                        <span id="ipLabel">IP: -</span>
                    </div>
                </div>
            </div>

            <button id="ui-toggle-corner-btn" title="UI 숨기기">◐</button>

            <div id="network-speed-indicator">
                <div class="speed-icon">⇅</div>
                <div class="speed-text">
                    <span class="speed-label">STREAM BANDWIDTH</span>
                    <span class="speed-value" id="networkSpeed">-- Mbps</span>
                </div>
                <div class="speed-latency" id="networkLatency">Latency -- ms</div>
            </div>

            <div id="control-panel">
                <div class="panel-card">
                    <h3>Immersion</h3>
                    <div class="button-row" style="margin-bottom:12px;">
                        <button class="primary-btn" id="enterVrBtn">Enter VR</button>
                        <button class="ghost-btn" id="recenterBtn">Re-center</button>
                        <button class="ghost-btn" id="toggleEnvBtn">Toggle Lights</button>
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Screen Distance</span>
                            <span id="distanceValue">3.2m</span>
                        </div>
                        <input type="range" id="distanceSlider" min="2" max="5" step="0.1" value="3.2">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Curvature</span>
                            <span id="curvatureValue">0%</span>
                        </div>
                        <input type="range" id="curvatureSlider" min="0" max="100" value="0">
                    </div>
                </div>

                <div class="panel-card">
                    <h3>Stream</h3>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Frame Rate</span>
                            <span id="fpsValue">24 FPS</span>
                        </div>
                        <input type="range" id="fpsSlider" min="5" max="45" value="24">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span>Sharpness</span>
                            <span id="qualityValue">80%</span>
                        </div>
                        <input type="range" id="qualitySlider" min="40" max="95" value="80">
                    </div>
                    <div class="button-row" style="margin-top:8px;">
                        <button class="ghost-btn" id="refreshHealthBtn">Check Health</button>
                        <button class="ghost-btn" id="togglePreviewBtn">Toggle Preview</button>
                    </div>
                    <p style="font-size:12px;color:rgba(255,255,255,0.7);margin-top:12px;" id="vrStatusMessage">
                        서버에 연결 중입니다...
                    </p>
                </div>

                <div class="panel-card">
                    <h3>Quest Checklist</h3>
                    <ul id="instruction-list">
                        <li>PC와 Quest가 동일 네트워크인지 확인</li>
                        <li>헤드셋 브라우저에서 <code id="questUrl">http://&lt;IP&gt;:5000</code> 접속</li>
                        <li>페이지가 열리면 "Enter VR"을 눌러 WebXR 세션 시작</li>
                        <li>프레임이 느리면 FPS 혹은 품질 슬라이더로 조절</li>
                    </ul>
                    <img id="mini-preview" alt="Stream preview">
                </div>

                <div class="panel-card">
                    <h3>Telemetry</h3>
                    <div id="log">Ready.</div>
                </div>
                <div class="panel-card">
                    <h3>VR Stereo</h3>
                    <div class="stereo-control-grid">
                        <div class="stereo-toggle-group">
                            <button class="stereo-toggle-btn active" id="toggleStereoBtn">Stereo ON</button>
                            <button class="stereo-toggle-btn" id="toggleDeconvexBtn">DeConvex OFF</button>
                            <button class="stereo-toggle-btn" id="toggleCannonBtn">Cannon OFF</button>
                        </div>
                        <div class="eye-toggle-row">
                            <span>Desktop Eye</span>
                            <div class="eye-btn-group">
                                <button id="eyeLeftBtn" class="active">Left</button>
                                <button id="eyeRightBtn">Right</button>
                            </div>
                        </div>
                        <p style="font-size:12px;color:rgba(255,255,255,0.65);">
                            DeConvex / Cannon 옵션으로 SBS 렌즈 왜곡을 교정할 수 있습니다.
                        </p>
                    </div>
                </div>
            </div>
            <button id="controlCollapseBtn" class="control-toggle-btn" aria-expanded="true">Hide Controls</button>
            <button id="controlCompactBtn" class="control-toggle-btn" aria-pressed="false">Compact Layout</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from '/static/vendor/three/three.module.js';
        import { OrbitControls } from '/static/vendor/three/OrbitControls.js';
        import { VRButton } from '/static/vendor/three/VRButton.js';
        import * as DeconvexShader from '/static/js/deconvex-shader.js';
        import * as CombinedLensShader from '/static/js/combined-lens-shader.js';
        import * as HVMapLoader from '/static/js/hvmap-loader.js';

        window.DeconvexShader = DeconvexShader;
        window.CombinedLensShader = CombinedLensShader;
        window.HVMapLoader = HVMapLoader;

        const canvas = document.getElementById('vrCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        const vrButton = VRButton.createButton(renderer);
        vrButton.style.display = 'none';
        document.body.appendChild(vrButton);

        let xrSession = null;
        const xrSessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers'],
            requiredFeatures: ['local-floor']
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.6, 3.2);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.6, 0);
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.enableZoom = false;

        const ambient = new THREE.AmbientLight(0xffffff, 0.45);
        const keyLight = new THREE.SpotLight(0x89c4ff, 1.1, 20, Math.PI / 4, 0.25, 1);
        keyLight.position.set(-3, 4, 2);
        const rimLight = new THREE.PointLight(0xffb347, 0.6, 10);
        rimLight.position.set(3, 1.8, 1.5);
        scene.add(ambient, keyLight, rimLight);

        const floor = new THREE.Mesh(
            new THREE.CircleGeometry(40, 64),
            new THREE.MeshStandardMaterial({ color: 0x0d0d0d, roughness: 0.85, metalness: 0.05 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.01;
        scene.add(floor);

        const frameCanvas = document.createElement('canvas');
        frameCanvas.width = 1280;
        frameCanvas.height = 720;
        const frameCtx = frameCanvas.getContext('2d');
        frameCtx.fillStyle = "#000";
        frameCtx.fillRect(0, 0, frameCanvas.width, frameCanvas.height);

        const frameTexture = new THREE.CanvasTexture(frameCanvas);
        frameTexture.encoding = THREE.sRGBEncoding;
        frameTexture.minFilter = THREE.LinearFilter;
        frameTexture.magFilter = THREE.LinearFilter;
        frameTexture.anisotropy = 4;

        let screenMesh = null;
        let stereoMeshes = { left: null, right: null, web: null };
        const screenState = {
            width: 4.0,
            height: 4.0 / (16 / 9),
            distance: 3.2,
            curvature: 0
        };

        const stereoState = {
            isStereoMode: true,
            deconvexEnabled: false,
            cannonEnabled: false,
            stereoEyeOffset: 0.0,
            cannonMaps: null,
            cannonLoading: false
        };
        const stereoEls = {};

        function disposeMesh(mesh) {
            if (!mesh) return;
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(mat => mat.dispose && mat.dispose());
                } else {
                    mesh.material.dispose && mesh.material.dispose();
                }
            }
            if (mesh.geometry) {
                mesh.geometry.dispose && mesh.geometry.dispose();
            }
            scene.remove(mesh);
        }

        function clearScreenMeshes() {
            if (screenMesh) {
                disposeMesh(screenMesh);
                screenMesh = null;
            }
            if (stereoMeshes.left) {
                disposeMesh(stereoMeshes.left);
            }
            if (stereoMeshes.right) {
                disposeMesh(stereoMeshes.right);
            }
            if (stereoMeshes.web) {
                disposeMesh(stereoMeshes.web);
            }
            stereoMeshes = { left: null, right: null, web: null };
        }

        function createPlaneScreen() {
            let geometry;
            if (screenState.curvature < 0.05) {
                geometry = new THREE.PlaneGeometry(screenState.width, screenState.height, 32, 1);
            } else {
                const segments = 96;
                geometry = new THREE.PlaneGeometry(screenState.width, screenState.height, segments, 1);
                const arc = THREE.MathUtils.lerp(Math.PI / 60, Math.PI / 1.4, screenState.curvature);
                const radius = screenState.width / arc;
                const pos = geometry.attributes.position;
                for (let i = 0; i < pos.count; i++) {
                    const x = pos.getX(i);
                    const angle = (x / screenState.width) * arc;
                    const targetX = Math.sin(angle) * radius;
                    const targetZ = radius - Math.cos(angle) * radius;
                    pos.setX(i, targetX);
                    pos.setZ(i, targetZ);
                }
                pos.needsUpdate = true;
                geometry.computeVertexNormals();
            }

            const material = new THREE.MeshBasicMaterial({
                map: frameTexture,
                side: THREE.DoubleSide,
                toneMapped: false
            });
            screenMesh = new THREE.Mesh(geometry, material);
            screenMesh.position.set(0, 1.6, -screenState.distance);
            scene.add(screenMesh);
        }

        function createHemisphereGeometry() {
            const radius = 100;
            return new THREE.SphereGeometry(
                radius,
                64,
                32,
                -Math.PI / 2,
                Math.PI,
                0,
                Math.PI
            );
        }

        function createStereoMaterial(mode) {
            const width = frameCanvas.width || 7680;
            const height = frameCanvas.height || 3840;
            let material = null;

            if (stereoState.cannonEnabled && stereoState.cannonMaps && CombinedLensShader?.createCombinedLensShaderMaterial) {
                material = CombinedLensShader.createCombinedLensShaderMaterial(frameTexture, stereoState.cannonMaps, {
                    srcWidth: width,
                    srcHeight: height,
                    outWidth: width,
                    outHeight: height,
                    enableDeconvex: stereoState.deconvexEnabled,
                    enableCannon: stereoState.cannonEnabled,
                    eyeMode: mode,
                    swapEyes: true
                });
            } else if (stereoState.deconvexEnabled && DeconvexShader?.createDeconvexShaderMaterial) {
                material = DeconvexShader.createDeconvexShaderMaterial(frameTexture, {
                    srcWidth: width,
                    srcHeight: height,
                    outWidth: width,
                    outHeight: height,
                    enableDeconvex: stereoState.deconvexEnabled,
                    eyeMode: mode
                });
            } else {
                const modeValue = mode === 'left' ? 0.0 : mode === 'right' ? 1.0 : 2.0;
                material = new THREE.ShaderMaterial({
                    uniforms: {
                        map: { value: frameTexture },
                        eyeMode: { value: modeValue },
                        eyeOffset: { value: stereoState.stereoEyeOffset }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D map;
                        uniform float eyeMode;
                        uniform float eyeOffset;
                        varying vec2 vUv;

                        vec4 sampleEye(bool leftEye) {
                            vec2 uv = leftEye
                                ? vec2(0.5 - vUv.x * 0.5, vUv.y)
                                : vec2(1.0 - vUv.x * 0.5, vUv.y);
                            return texture2D(map, uv);
                        }

                        void main() {
                            if (eyeMode < 0.5) {
                                gl_FragColor = sampleEye(true);
                            } else if (eyeMode < 1.5) {
                                gl_FragColor = sampleEye(false);
                            } else {
                                bool showLeft = eyeOffset < 0.25;
                                gl_FragColor = sampleEye(showLeft);
                            }
                        }
                    `
                });
            }

            if (mode === 'hemisphere' && material.uniforms && material.uniforms.eyeOffset) {
                material.uniforms.eyeOffset.value = stereoState.stereoEyeOffset;
            }
            material.side = THREE.BackSide;
            material.toneMapped = false;
            return material;
        }

        function createWebStereoMesh() {
            const geometry = createHemisphereGeometry();
            const material = createStereoMaterial('hemisphere');
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.y = -Math.PI / 2;
            mesh.layers.set(0);
            stereoMeshes.web = mesh;
            scene.add(mesh);
        }

        function createVrStereoMeshes() {
            const leftMesh = new THREE.Mesh(createHemisphereGeometry(), createStereoMaterial('left'));
            leftMesh.rotation.y = -Math.PI / 2;
            leftMesh.layers.set(1);

            const rightMesh = new THREE.Mesh(createHemisphereGeometry(), createStereoMaterial('right'));
            rightMesh.rotation.y = -Math.PI / 2;
            rightMesh.layers.set(2);

            stereoMeshes.left = leftMesh;
            stereoMeshes.right = rightMesh;
            scene.add(leftMesh);
            scene.add(rightMesh);
            camera.layers.enable(1);
            camera.layers.enable(2);
            updateXrCameraLayers();
        }

        function updateXrCameraLayers() {
            if (!renderer.xr.isPresenting || !stereoState.isStereoMode) {
                camera.layers.set(0);
                return;
            }

            camera.layers.enable(1);
            camera.layers.enable(2);

            try {
                const xrCamera = renderer.xr.getCamera(camera);
                if (xrCamera && xrCamera.isArrayCamera && xrCamera.cameras) {
                    const [leftEye, rightEye] = xrCamera.cameras;
                    if (leftEye && leftEye.layers) {
                        leftEye.layers.set(1);
                    }
                    if (rightEye && rightEye.layers) {
                        rightEye.layers.set(2);
                    }
                }
            } catch (err) {
                console.warn('XR camera layer update failed:', err.message);
            }
        }

        function rebuildScreen() {
            clearScreenMeshes();
            if (stereoState.isStereoMode) {
                if (renderer.xr.isPresenting) {
                    createVrStereoMeshes();
                } else {
                    createWebStereoMesh();
                }
            } else {
                createPlaneScreen();
            }
            updateXrCameraLayers();
        }

        rebuildScreen();

        async function ensureCannonMaps() {
            if (stereoState.cannonMaps) {
                return stereoState.cannonMaps;
            }
            if (stereoState.cannonLoading) {
                while (stereoState.cannonLoading && !stereoState.cannonMaps) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                return stereoState.cannonMaps;
            }
            if (!HVMapLoader || !HVMapLoader.loadHVMapLR) {
                return null;
            }
            stereoState.cannonLoading = true;
            updateStereoButtons();
            try {
                stereoState.cannonMaps = await HVMapLoader.loadHVMapLR(
                    '/static/presets/Cannon_L.hvmap',
                    '/static/presets/Cannon_R.hvmap'
                );
                log('Cannon lens presets loaded');
            } catch (err) {
                console.error('Failed to load Cannon lens presets:', err);
                log('Failed to load Cannon lens presets');
                stereoState.cannonMaps = null;
            } finally {
                stereoState.cannonLoading = false;
                updateStereoButtons();
            }
            return stereoState.cannonMaps;
        }

        function updateStereoButtons() {
            if (stereoEls.stereoBtn) {
                stereoEls.stereoBtn.classList.toggle('active', stereoState.isStereoMode);
                stereoEls.stereoBtn.textContent = stereoState.isStereoMode ? 'Stereo ON' : 'Stereo OFF';
            }
            if (stereoEls.deconvexBtn) {
                stereoEls.deconvexBtn.classList.toggle('active', stereoState.deconvexEnabled);
                stereoEls.deconvexBtn.textContent = stereoState.deconvexEnabled ? 'DeConvex ON' : 'DeConvex OFF';
            }
            if (stereoEls.cannonBtn) {
                const enabled = stereoState.cannonEnabled;
                stereoEls.cannonBtn.classList.toggle('active', enabled);
                stereoEls.cannonBtn.classList.toggle('cannon-active', enabled);
                stereoEls.cannonBtn.textContent = enabled ? 'Cannon ON' : 'Cannon OFF';
                stereoEls.cannonBtn.disabled = stereoState.cannonLoading;
            }
            if (stereoEls.eyeLeftBtn && stereoEls.eyeRightBtn) {
                stereoEls.eyeLeftBtn.classList.toggle('active', stereoState.stereoEyeOffset < 0.25);
                stereoEls.eyeRightBtn.classList.toggle('active', stereoState.stereoEyeOffset >= 0.25);
            }
        }

        function setEyeOffset(offset) {
            stereoState.stereoEyeOffset = offset;
            if (stereoMeshes.web && stereoMeshes.web.material && stereoMeshes.web.material.uniforms && stereoMeshes.web.material.uniforms.eyeOffset) {
                stereoMeshes.web.material.uniforms.eyeOffset.value = offset;
            }
            updateStereoButtons();
        }

        function toggleStereoMode() {
            stereoState.isStereoMode = !stereoState.isStereoMode;
            controls.enablePan = !stereoState.isStereoMode;
            controls.enableZoom = !stereoState.isStereoMode;
            updateStereoButtons();
            rebuildScreen();
        }

        function toggleDeconvex() {
            stereoState.deconvexEnabled = !stereoState.deconvexEnabled;
            updateStereoButtons();
            rebuildScreen();
        }

        async function toggleCannon() {
            if (!stereoState.cannonEnabled) {
                const maps = await ensureCannonMaps();
                if (!maps) {
                    alert('Cannon 렌즈 프리셋을 불러올 수 없습니다.');
                    return;
                }
                stereoState.cannonEnabled = true;
            } else {
                stereoState.cannonEnabled = false;
            }
            updateStereoButtons();
            rebuildScreen();
        }

        function resizeRenderer() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }

        window.addEventListener('resize', resizeRenderer);

        function animate() {
            renderer.setAnimationLoop(() => {
                if (!renderer.xr.isPresenting) {
                    controls.update();
                }
                renderer.render(scene, camera);
            });
        }

        animate();

        const state = {
            streaming: true,
            fps: 24,
            quality: 80,
            lightsOn: true,
            previewVisible: true,
            useFrameEndpoint: true
        };

        const logEl = document.getElementById('log');
        function log(message) {
            const time = new Date().toLocaleTimeString();
            logEl.textContent = `[${time}] ${message}\n` + logEl.textContent;
        }

        const serverStatusChip = document.getElementById('serverStatusChip');
        const serverStatusLabel = document.getElementById('serverStatusLabel');
        const vrModeLabel = document.getElementById('vrModeLabel');
        const ipLabel = document.getElementById('ipLabel');
        const questUrl = document.getElementById('questUrl');
        const statusMessage = document.getElementById('vrStatusMessage');
        const miniPreview = document.getElementById('mini-preview');
        miniPreview.crossOrigin = "anonymous";
        miniPreview.src = "/video_feed";
        const collapseBtn = document.getElementById('controlCollapseBtn');
        const compactBtn = document.getElementById('controlCompactBtn');
        let controlsCollapsed = false;
        let controlsCompact = window.innerWidth < 1500;
        let compactManualOverride = false;

        stereoEls.stereoBtn = document.getElementById('toggleStereoBtn');
        stereoEls.deconvexBtn = document.getElementById('toggleDeconvexBtn');
        stereoEls.cannonBtn = document.getElementById('toggleCannonBtn');
        stereoEls.eyeLeftBtn = document.getElementById('eyeLeftBtn');
        stereoEls.eyeRightBtn = document.getElementById('eyeRightBtn');
        updateStereoButtons();
        setEyeOffset(0.0);

        function updateCollapseState() {
            document.body.classList.toggle('controls-collapsed', controlsCollapsed);
            if (collapseBtn) {
                collapseBtn.textContent = controlsCollapsed ? 'Show Controls' : 'Hide Controls';
                collapseBtn.setAttribute('aria-expanded', (!controlsCollapsed).toString());
            }
        }

        function updateCompactState() {
            document.body.classList.toggle('controls-compact', controlsCompact);
            if (compactBtn) {
                compactBtn.textContent = controlsCompact ? 'Full Layout' : 'Compact Layout';
                compactBtn.setAttribute('aria-pressed', controlsCompact ? 'true' : 'false');
            }
        }

        if (collapseBtn) {
            collapseBtn.addEventListener('click', () => {
                controlsCollapsed = !controlsCollapsed;
                updateCollapseState();
            });
        }
        updateCollapseState();

        if (compactBtn) {
            compactBtn.addEventListener('click', () => {
                controlsCompact = !controlsCompact;
                compactManualOverride = true;
                updateCompactState();
            });
        }
        updateCompactState();

        const compactMedia = window.matchMedia('(max-width: 1500px)');
        const compactMediaHandler = (evt) => {
            if (compactManualOverride) return;
            controlsCompact = evt.matches;
            updateCompactState();
        };
        if (compactMedia.addEventListener) {
            compactMedia.addEventListener('change', compactMediaHandler);
        } else if (compactMedia.addListener) {
            compactMedia.addListener(compactMediaHandler);
        }

        function setServerStatus(text, online) {
            serverStatusLabel.textContent = text;
            serverStatusChip.classList.remove('online', 'offline');
            serverStatusChip.classList.add(online ? 'online' : 'offline');
        }

        function updateNetworkIndicator(bytes, elapsedMs) {
            const bits = bytes * 8;
            const kbps = bits / elapsedMs;
            const mbps = (kbps / 1000).toFixed(2);
            document.getElementById('networkSpeed').textContent = `${mbps} Mbps`;
            document.getElementById('networkLatency').textContent = `Latency ${Math.round(elapsedMs)} ms`;
        }

        async function fetchFrameLoop() {
            while (state.streaming && state.useFrameEndpoint) {
                const start = performance.now();
                try {
                    const response = await fetch(`/frame.jpg?ts=${Date.now()}`, { cache: "no-store" });
                    if (!response.ok) {
                        throw new Error(response.statusText);
                    }
                    const blob = await response.blob();
                    const bitmap = await createImageBitmap(blob);
                    if (frameCanvas.width !== bitmap.width || frameCanvas.height !== bitmap.height) {
                        frameCanvas.width = bitmap.width;
                        frameCanvas.height = bitmap.height;
                    }
                    frameCtx.drawImage(bitmap, 0, 0, frameCanvas.width, frameCanvas.height);
                    frameTexture.needsUpdate = true;
                    statusMessage.textContent = "스트림 연결됨. VR 버튼을 눌러 감상하세요.";
                    setServerStatus("Server online", true);
                    updateNetworkIndicator(blob.size, performance.now() - start);
                } catch (err) {
                    statusMessage.textContent = `프레임 수신 실패: ${err.message}`;
                    setServerStatus("Server offline", false);
                    await new Promise(r => setTimeout(r, 1000));
                }

                const elapsed = performance.now() - start;
                const wait = Math.max(5, (1000 / state.fps) - elapsed);
                await new Promise(r => setTimeout(r, wait));
            }
        }

        function startMjpegFallback() {
            state.useFrameEndpoint = false;
            setServerStatus("Server online", true);
            statusMessage.textContent = "스트림 연결됨 (MJPEG fallback).";
            log("frame.jpg unavailable. Using /video_feed stream for canvas texture.");

            function pump() {
                if (state.useFrameEndpoint || !state.streaming) {
                    return;
                }
                if (miniPreview.naturalWidth > 0 && miniPreview.naturalHeight > 0) {
                    if (frameCanvas.width !== miniPreview.naturalWidth || frameCanvas.height !== miniPreview.naturalHeight) {
                        frameCanvas.width = miniPreview.naturalWidth;
                        frameCanvas.height = miniPreview.naturalHeight;
                    }
                    frameCtx.drawImage(miniPreview, 0, 0, frameCanvas.width, frameCanvas.height);
                    frameTexture.needsUpdate = true;
                }
                if (!state.useFrameEndpoint && state.streaming) {
                    requestAnimationFrame(pump);
                }
            }

            // MJPEG streams never fire a load event because the request stays open.
            // Start pumping immediately and rely on naturalWidth checks to skip blank frames.
            pump();
        }

        async function probeFrameEndpoint() {
            try {
                const res = await fetch(`/frame.jpg?probe=${Date.now()}`, { cache: "no-store" });
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }
                await res.blob();
                return true;
            } catch (err) {
                log(`frame.jpg unavailable (${err.message}). Falling back to /video_feed.`);
                return false;
            }
        }

        async function beginStreaming() {
            startMjpegFallback();
            const hasFrameEndpoint = await probeFrameEndpoint();
            if (hasFrameEndpoint) {
                state.useFrameEndpoint = true;
                fetchFrameLoop();
            }
        }

        beginStreaming();

        async function refreshHealth() {
            try {
                const res = await fetch('/health', { cache: 'no-store' });
                const data = await res.json();
                if (data.ip) {
                    ipLabel.textContent = `IP: ${data.ip}`;
                    questUrl.textContent = `http://${data.ip}:5000`;
                }
                if (data.bbox) {
                    frameCanvas.width = data.bbox.width;
                    frameCanvas.height = data.bbox.height;
                    frameTexture.needsUpdate = true;
                    if (stereoState.isStereoMode) {
                        rebuildScreen();
                    }
                }
                setServerStatus("Server online", true);
                statusMessage.textContent = "Quest에서 같은 주소로 접속하세요.";
            } catch (err) {
                setServerStatus("Server offline", false);
                statusMessage.textContent = "서버에 연결할 수 없습니다.";
                log(`Health check failed: ${err.message}`);
            }
        }

        refreshHealth();
        setInterval(refreshHealth, 15000);

        document.getElementById('fpsSlider').addEventListener('input', (e) => {
            state.fps = parseInt(e.target.value, 10);
            document.getElementById('fpsValue').textContent = `${state.fps} FPS`;
            fetch('/update_config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fps: state.fps })
            }).catch(() => { });
        });

        document.getElementById('qualitySlider').addEventListener('input', (e) => {
            state.quality = parseInt(e.target.value, 10);
            document.getElementById('qualityValue').textContent = `${state.quality}%`;
            fetch('/update_config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ quality: state.quality })
            }).catch(() => { });
        });

        document.getElementById('distanceSlider').addEventListener('input', (e) => {
            screenState.distance = parseFloat(e.target.value);
            document.getElementById('distanceValue').textContent = `${screenState.distance.toFixed(1)}m`;
            if (!stereoState.isStereoMode) {
                rebuildScreen();
            }
        });

        document.getElementById('curvatureSlider').addEventListener('input', (e) => {
            screenState.curvature = parseInt(e.target.value, 10) / 100;
            document.getElementById('curvatureValue').textContent = `${e.target.value}%`;
            if (!stereoState.isStereoMode) {
                rebuildScreen();
            }
        });

        if (stereoEls.stereoBtn) {
            stereoEls.stereoBtn.addEventListener('click', () => toggleStereoMode());
        }
        if (stereoEls.deconvexBtn) {
            stereoEls.deconvexBtn.addEventListener('click', () => toggleDeconvex());
        }
        if (stereoEls.cannonBtn) {
            stereoEls.cannonBtn.addEventListener('click', () => toggleCannon());
        }
        if (stereoEls.eyeLeftBtn) {
            stereoEls.eyeLeftBtn.addEventListener('click', () => setEyeOffset(0.0));
        }
        if (stereoEls.eyeRightBtn) {
            stereoEls.eyeRightBtn.addEventListener('click', () => setEyeOffset(0.5));
        }

        document.getElementById('toggleEnvBtn').addEventListener('click', () => {
            state.lightsOn = !state.lightsOn;
            keyLight.visible = state.lightsOn;
            rimLight.visible = state.lightsOn;
            log(`Lights ${state.lightsOn ? 'on' : 'off'}`);
        });

        document.getElementById('togglePreviewBtn').addEventListener('click', () => {
            state.previewVisible = !state.previewVisible;
            miniPreview.style.display = state.previewVisible ? 'block' : 'none';
        });

        document.getElementById('refreshHealthBtn').addEventListener('click', refreshHealth);

        document.getElementById('recenterBtn').addEventListener('click', () => {
            const targetZ = stereoState.isStereoMode ? 3.2 : screenState.distance;
            camera.position.set(0, 1.6, targetZ);
            controls.target.set(0, 1.6, 0);
            controls.update();
            log('Camera re-centered');
        });

        const enterVrBtn = document.getElementById('enterVrBtn');

        async function startVrSession() {
            if (!navigator.xr) {
                alert('이 브라우저는 WebXR을 지원하지 않습니다.');
                return;
            }
            if (xrSession) {
                try {
                    await xrSession.end();
                } catch (err) {
                    log(`세션 종료 실패: ${err.message}`);
                }
                return;
            }
            try {
                const session = await navigator.xr.requestSession('immersive-vr', xrSessionInit);
                await renderer.xr.setSession(session);
                xrSession = session;
                enterVrBtn.textContent = 'Exit VR';
                log('VR 세션 시작');
                session.addEventListener('end', () => {
                    xrSession = null;
                    enterVrBtn.textContent = 'Enter VR';
                    log('VR 세션 종료');
                    rebuildScreen();
                    updateXrCameraLayers();
                }, { once: true });
            } catch (err) {
                log(`VR 세션 시작 실패: ${err.message}`);
                alert('VR 세션을 시작할 수 없습니다.\n' + err.message);
            }
        }

        enterVrBtn.addEventListener('click', () => {
            if (!navigator.xr) {
                alert('WebXR을 지원하지 않는 환경입니다.');
                return;
            }
            startVrSession();
        });

        renderer.xr.addEventListener('sessionstart', () => {
            vrModeLabel.textContent = 'VR Session Active';
            enterVrBtn.textContent = 'Exit VR';
            rebuildScreen();
            updateXrCameraLayers();
        });

        renderer.xr.addEventListener('sessionend', () => {
            vrModeLabel.textContent = 'Desktop Preview';
            enterVrBtn.textContent = 'Enter VR';
            rebuildScreen();
            updateXrCameraLayers();
        });

        document.getElementById('ui-toggle-corner-btn').addEventListener('click', () => {
            document.body.classList.toggle('overlay-hidden');
        });
    </script>
</body>

</html>
